# PW6 实验报告

PB21000193 徐翊然 PB21111639 李牧龙

## 问题回答
### part1
**1:**  

下面是go_upstaits生成的llvm代码的一部分，删除了与while主体无关的部分
```
10:                                               ; preds = %1
  ......
  br label %14		;跳转到while条件判断部分
  
14:   ;两情况：一次while循环结束或第一次进入循环                                   ; preds = %19, %10
  ......
  %18 = icmp slt i32 %15, %17      ;计算跳转标志
  br i1 %18, label %19, label %36	;根据跳转标志情况决定是否离开循环

19:                                               ; preds = %14
  ......
  br label %14, !llvm.loop !6    ;while一次循环结束，跳到开头判断是否还要再进行一次循环

36:       ;while循环之后的代码                                        ; preds = %14
  ......
```

**2:** `%11 = call i32 @climbStairs(i32 noundef %10)` 从这个定义可以看出函数调用使用call语句，紧跟一个函数返回类型，接着是函数名。然后是函数可能的调用参数。同时函数的返回值可以直接被赋值给某个变量。

### part2
通过上网查询资料可以知道事实上`<result> = getelementptr <type1>, <type2>* <ptrval> [, <type_k> <idx_k>]` 中第一个<type_k> <idx_k>对是索引的<type2>类型的指针上的偏移量，于是`%2 = getelementptr [10 x i32], [10 x i32]* %1, i32 0, i32 %0` 中第一个 `i32 0`实际作用是取得[10 x i32]类型数组的基地址，而后续的`i32 %0`完成在数组基地址上向后索引元素。对于`%2 = getelementptr i32, i32* %1, i32 %0`，由于其类型本身就是`i32 *`，因此可以直接索引而不会出错。

### part3
1. 可以轻松找到在一个语句块内变量的引用对应的真实同名变量。
2. 在处理数组的时候可以获得各个维度信息，方便生成地址计算代码。

## 实验设计

从下向上分工编写IRBuilder，注意让熟悉某一部分的人编写与该部分紧密相关的部分，如while编写者写continue、break，Lval与AssignStmt由一个人负责。

## 实验难点及解决方案

1. 对实验框架的理解，这一困难可以通过在相关文件中搜索来实现。
2. 如何实现逻辑表达式计算，最后决定所有逻辑表达式求值无论是否为and、or都统一返回一个1bit的bool值，通过这一bool值让if、while语句决定如何执行。这样分离了表达式的求值与使用，与课本方法相比实现了生成器各部分的解耦。
3. 如何实现and及or表达式的短路计算，由于助教提供的框架中没有相应的位运算代码，同时由于静态单赋值语句的特性，使保存and左右表达式结果困难，最终结果难以确定位置。于是通过引入中间变量的方式存储左右表达式计算结果，并通过跳转语句实现短路计算。具体方式为先将左表达式计算结果存入临时变量，然后根据左表达式结果决定是否跳转到结尾，如果不需跳转则求右表达式值并将其放入同一临时变量中。在结尾处则将临时变量的值加载入某一寄存器并将这一寄存器作为表达式求值结果。通过这一方式也可以实现or的短路计算。
4. 由于助教框架原因，遇到if(a)这类表达式时访问a直接由LVal分支负责，跳过了一切与条件表达式有关分支。为了解决这一问题，最后迫不得已在if、while访问条件表达式的代码后增加判断模块，如果访问结果不是bool值则通过生成a==0这种语句实现LVal到bool值的转换。
5. while语句内可能出现break、continue语句，这些语句需要找到其外层对应的第一个while。为了简单实现这一功能，定义三个while相关基本块指针While_cond、While_body、While_end。当遇到break时就生成跳转到While_end的跳转语句，continue则生成跳转到While_cond的语句。而每当进入一个WhileStmt访问时都把之前的While_cond、While_body、While_end保存，并将新的While_cond、While_body、While_end放入，离开时则恢复While_cond、While_body、While_end，从而实现跟踪最内层while。
6. 代码框架提供的接口中没有memcpy这一类可以直接为数组内容赋值的函数，因此局部数组的初始化使用了大量的store语句。

## 实验总结

本次实验实现了llvm的中间代码生成，初步理解了llvm代码生成框架，实现了and、or语句的短路计算。

## 实验反馈

1. 建议添加if(a)这类表达式处理的相关访问函数。
2. 希望添加memcpy的接口

## 组间交流
