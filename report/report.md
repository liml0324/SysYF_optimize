# PW6 实验报告

PB21000193 徐翊然 PB21111639 李牧龙

## 问题回答
### part1
**1:**  

下面是go_upstaits生成的llvm代码的一部分，删除了与while主体无关的部分
```
10:                                               ; preds = %1
  ......
  br label %14		;跳转到while条件判断部分
  
14:   ;两情况：一次while循环结束或第一次进入循环                                   ; preds = %19, %10
  ......
  %18 = icmp slt i32 %15, %17      ;计算跳转标志
  br i1 %18, label %19, label %36	;根据跳转标志情况决定是否离开循环

19:                                               ; preds = %14
  ......
  br label %14, !llvm.loop !6    ;while一次循环结束，跳到开头判断是否还要再进行一次循环

36:       ;while循环之后的代码                                        ; preds = %14
  ......
```

**2:** `%11 = call i32 @climbStairs(i32 noundef %10)` 从这个定义可以看出函数调用使用call语句，紧跟一个函数返回类型，接着是函数名。然后是函数可能的调用参数。同时函数的返回值可以直接被赋值给某个变量。

### part2
通过上网查询资料可以知道事实上`<result> = getelementptr <type1>, <type2>* <ptrval> [, <type_k> <idx_k>]` 中第一个<type_k> <idx_k>对是索引的<type2>类型的指针上的偏移量，于是`%2 = getelementptr [10 x i32], [10 x i32]* %1, i32 0, i32 %0` 中第一个 `i32 0`实际作用是取得[10 x i32]类型数组的基地址，而后续的`i32 %0`完成在数组基地址上向后索引元素。对于`%2 = getelementptr i32, i32* %1, i32 %0`，由于其类型本身就是`i32 *`，因此可以直接索引而不会出错。

### part3
1. 可以轻松找到函数执行时一个变量引用对应的真实同名变量。

## 实验设计

## 实验难点及解决方案

## 实验总结

## 实验反馈

## 组间交流
